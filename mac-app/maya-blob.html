<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Maya</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 120px;
      height: 120px;
      overflow: hidden;
      background: transparent;
      -webkit-app-region: drag;
    }
    .maya-blob-shell {
      position: fixed;
      width: 120px;
      height: 120px;
      display: grid;
      place-items: center;
      pointer-events: auto;
      -webkit-app-region: no-drag;
      cursor: pointer;
    }
    .maya-blob-card {
      position: relative;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .maya-blob-card:hover { transform: scale(1.1); }
    .maya-blob-card:active { transform: scale(0.95); }
    .maya-blob-card::before,
    .maya-blob-card::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid rgba(77, 255, 163, 0.6);
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      pointer-events: none;
    }
    .maya-blob-card.speaking::before { animation: maya-pulse-ring 1.5s ease-out infinite; }
    .maya-blob-card.speaking::after { animation: maya-pulse-ring 1.5s ease-out infinite 0.75s; }
    @keyframes maya-pulse-ring {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; }
    }
    .maya-blob-card.speaking {
      filter: drop-shadow(0 0 60px rgba(77, 255, 163, 1)) drop-shadow(0 0 30px rgba(77, 255, 200, 0.8));
      animation: maya-blob-speak-pulse 0.6s ease-in-out infinite;
    }
    @keyframes maya-blob-speak-pulse {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.15); }
      50% { transform: scale(1.08); }
      75% { transform: scale(1.2); }
    }
    /* Listening indicator */
    .maya-blob-card.listening {
      filter: drop-shadow(0 0 20px rgba(77, 163, 255, 0.8));
    }
    .maya-blob-card.listening::before {
      animation: maya-listen-ring 2s ease-in-out infinite;
      border-color: rgba(77, 163, 255, 0.5);
    }
    @keyframes maya-listen-ring {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
      50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.2; }
    }
    .maya-blob-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    /* Mic indicator */
    .mic-indicator {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .mic-indicator.active {
      opacity: 1;
      color: rgba(77, 255, 163, 0.9);
    }
  </style>
</head>
<body>
  <div class="maya-blob-shell" id="mayaBlobShell" title="Click to open MAYA or say 'Hey Maya'">
    <div class="maya-blob-card" id="mayaBlobCard">
      <canvas class="maya-blob-canvas" id="mayaBlobCanvas"></canvas>
    </div>
    <div class="mic-indicator" id="micIndicator">ðŸŽ¤ Listening...</div>
  </div>
  <script>
    const card = document.getElementById('mayaBlobCard');
    const canvas = document.getElementById('mayaBlobCanvas');
    const micIndicator = document.getElementById('micIndicator');
    const ctx = canvas.getContext('2d');
    const COLORS = [
      { start: 'rgba(77, 255, 163, 0.9)', end: 'rgba(0, 200, 150, 0.3)' },
      { start: 'rgba(100, 220, 255, 0.85)', end: 'rgba(50, 150, 255, 0.25)' },
      { start: 'rgba(139, 93, 255, 0.8)', end: 'rgba(100, 50, 200, 0.2)' },
      { start: 'rgba(255, 180, 100, 0.75)', end: 'rgba(255, 120, 50, 0.2)' }
    ];
    let BLOBS = [];
    const rand = (min, max) => Math.random() * (max - min) + min;
    const noise = (x, y, t) => Math.sin(x * 0.5 + t) * Math.cos(y * 0.5 + t) * 0.5 + 0.5;

    function initBlobs() {
      canvas.width = canvas.height = 72;
      const cx = 36, cy = 36;
      BLOBS = [];
      for (let i = 0; i < 4; i++) {
        const angle = rand(0, Math.PI * 2);
        const dist = rand(0, 8);
        const r = rand(18, 28);
        const homeX = cx + Math.cos(angle) * dist;
        const homeY = cy + Math.sin(angle) * dist;
        BLOBS.push({
          x: homeX, y: homeY, r,
          vx: rand(-0.2, 0.2), vy: rand(-0.2, 0.2),
          hx: homeX, hy: homeY,
          palette: COLORS[i],
          noiseOffset: rand(0, 1000)
        });
      }
    }

    function drawBlob(b, now) {
      const points = 8;
      const angleStep = (Math.PI * 2) / points;
      const grd = ctx.createRadialGradient(b.x, b.y, b.r * 0.1, b.x, b.y, b.r * 1.3);
      grd.addColorStop(0, b.palette.start);
      grd.addColorStop(1, b.palette.end);
      const pts = [];
      for (let i = 0; i < points; i++) {
        const angle = i * angleStep;
        const n = noise(Math.cos(angle) + b.noiseOffset, Math.sin(angle) + b.noiseOffset, now * 0.0008);
        const offset = b.r * 0.15 * (n - 0.5) * 2;
        pts.push({
          x: b.x + Math.cos(angle) * (b.r + offset),
          y: b.y + Math.sin(angle) * (b.r + offset)
        });
      }
      ctx.beginPath();
      ctx.moveTo((pts[0].x + pts[points-1].x) / 2, (pts[0].y + pts[points-1].y) / 2);
      for (let i = 0; i < points; i++) {
        const p1 = pts[i];
        const p2 = pts[(i + 1) % points];
        const mx = (p1.x + p2.x) / 2;
        const my = (p1.y + p2.y) / 2;
        ctx.quadraticCurveTo(p1.x, p1.y, mx, my);
      }
      ctx.closePath();
      ctx.fillStyle = grd;
      ctx.fill();
    }

    function animate(now) {
      ctx.clearRect(0, 0, 72, 72);
      for (const b of BLOBS) {
        b.vx += (b.hx - b.x) * 0.012;
        b.vy += (b.hy - b.y) * 0.012;
        b.vx *= 0.97; b.vy *= 0.97;
        b.x += b.vx; b.y += b.vy;
        drawBlob(b, now);
      }
      requestAnimationFrame(animate);
    }

    initBlobs();
    animate(0);

    card.addEventListener('click', async () => {
      if (window.talioDesktop) await window.talioDesktop.openMayaFromBlob();
    });

    // ==================== WAKE WORD DETECTION ====================
    let recognition = null;
    let isListening = false;
    let restartTimeout = null;
    const RESTART_DELAY = 300;

    const WAKE_WORDS = [
      'maya', 'maia', 'mya', 'maia', 'maya',
      'hey maya', 'hey maia', 'hey mya', 'hey mia',
      'hi maya', 'hi maia', 'hi mya', 'hi mia',
      'ok maya', 'okay maya', 'o k maya',
      'hello maya', 'hello maia',
      'yo maya', 'yo maia'
    ];

    function levenshteinDistance(a, b) {
      const matrix = [];
      for (let i = 0; i <= b.length; i++) matrix[i] = [i];
      for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
          }
        }
      }
      return matrix[b.length][a.length];
    }

    function checkWakeWord(transcript) {
      const lower = transcript.toLowerCase().trim();
      for (const word of WAKE_WORDS) {
        if (lower.includes(word)) return true;
      }
      const words = lower.split(/\s+/);
      for (const word of words) {
        const mayaVariants = ['maya', 'maia', 'mya', 'mia'];
        for (const variant of mayaVariants) {
          if (levenshteinDistance(word, variant) <= 1) return true;
        }
      }
      if (lower.includes('hey') || lower.includes('hi') || lower.includes('ok') || lower.includes('hello')) {
        for (const word of words) {
          for (const variant of ['maya', 'maia', 'mya', 'mia']) {
            if (levenshteinDistance(word, variant) <= 2) return true;
          }
        }
      }
      return false;
    }

    function setListeningState(listening) {
      isListening = listening;
      if (listening) {
        card.classList.add('listening');
        micIndicator.classList.add('active');
      } else {
        card.classList.remove('listening');
        micIndicator.classList.remove('active');
      }
    }

    function initWakeWordDetection() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.log('[Maya Blob] Speech recognition not supported');
        return false;
      }
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      recognition.maxAlternatives = 5;

      recognition.onstart = () => {
        console.log('[Maya Blob] Wake word listening started');
        setListeningState(true);
      };

      recognition.onresult = async (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const result = event.results[i];
          for (let j = 0; j < result.length; j++) {
            const transcript = result[j].transcript;
            if (checkWakeWord(transcript)) {
              console.log('[Maya Blob] Wake word detected:', transcript);
              card.classList.add('speaking');
              card.classList.remove('listening');
              micIndicator.textContent = 'âœ¨ Opening...';
              stopWakeWordListening();
              if (window.talioDesktop) await window.talioDesktop.openMayaFromBlob();
              setTimeout(() => {
                card.classList.remove('speaking');
                micIndicator.textContent = 'ðŸŽ¤ Listening...';
              }, 1000);
              return;
            }
          }
        }
      };

      recognition.onerror = (e) => {
        console.log('[Maya Blob] Speech recognition error:', e.error);
        setListeningState(false);
        if (e.error === 'not-allowed') {
          micIndicator.textContent = 'ðŸ”‡ Mic denied';
          micIndicator.classList.add('active');
        } else {
          scheduleRestart();
        }
      };

      recognition.onend = () => {
        console.log('[Maya Blob] Recognition ended');
        setListeningState(false);
        scheduleRestart();
      };
      return true;
    }

    function scheduleRestart() {
      if (restartTimeout) clearTimeout(restartTimeout);
      restartTimeout = setTimeout(() => startWakeWordListening(), RESTART_DELAY);
    }

    function startWakeWordListening() {
      if (!recognition && !initWakeWordDetection()) return;
      if (recognition && !isListening) {
        try {
          recognition.start();
        } catch (e) {
          if (e.message && e.message.includes('already started')) {
            setListeningState(true);
          } else {
            scheduleRestart();
          }
        }
      }
    }

    function stopWakeWordListening() {
      if (restartTimeout) { clearTimeout(restartTimeout); restartTimeout = null; }
      setListeningState(false);
      try { recognition?.stop(); } catch (e) {}
    }

    console.log('[Maya Blob] Initializing wake word detection...');
    setTimeout(() => startWakeWordListening(), 500);
    setInterval(() => { if (!isListening && recognition) startWakeWordListening(); }, 5000);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') setTimeout(() => startWakeWordListening(), 300);
    });
    window.addEventListener('focus', () => setTimeout(() => startWakeWordListening(), 300));
  </script>
</body>
</html>
