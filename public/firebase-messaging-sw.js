// Combined Service Worker: PWA + Firebase Cloud Messaging
// This file handles both PWA caching (Workbox) and FCM push notifications
// AUTO-GENERATED - Do not edit directly! Generated by scripts/generate-firebase-sw.js

console.log('[SW] Combined Service Worker starting...')

// Import Firebase scripts for Cloud Messaging
importScripts('https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js')
importScripts('https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js')

// Firebase configuration - Talio HRMS Project
// Configuration loaded from environment variables at build time
const firebaseConfig = {
  "apiKey": "AIzaSyDsJgwFuOjgg4QFox6xw8Gg4rs5oub4ZD8",
  "authDomain": "talio-a269f.firebaseapp.com",
  "projectId": "talio-a269f",
  "storageBucket": "talio-a269f.firebasestorage.app",
  "messagingSenderId": "748268440394",
  "appId": "1:748268440394:web:c659dbece00a2501c28fb3"
}

// Initialize Firebase
let messaging = null
try {
  firebase.initializeApp(firebaseConfig)
  messaging = firebase.messaging()
  console.log('[SW] Firebase Messaging initialized successfully')
} catch (error) {
  console.error('[SW] Firebase initialization error:', error)
}

// Handle background messages (when app is closed or in background)
if (messaging) {
  messaging.onBackgroundMessage((payload) => {
    console.log('[SW] ðŸ“© Background FCM message received:', payload)

    const notificationTitle = payload.notification?.title || 'Talio HRMS'
    const notificationBody = payload.notification?.body || 'You have a new notification'

    // Enhanced notification options for WhatsApp-like behavior
    const notificationOptions = {
      body: notificationBody,
      icon: payload.notification?.icon || '/icons/icon-192x192.png',
      badge: '/icons/icon-96x96.png',
      tag: payload.data?.tag || payload.data?.type || 'talio-notification',
      data: {
        url: payload.data?.clickAction || payload.data?.click_action || payload.fcmOptions?.link || '/dashboard',
        ...payload.data
      },
      // Enhanced interaction settings
      vibrate: [200, 100, 200, 100, 200], // More noticeable vibration pattern
      requireInteraction: false, // Auto-dismiss after timeout
      silent: false, // Use device's default notification sound
      renotify: true, // Show notification even if one with same tag exists
      timestamp: Date.now(),
      // Action buttons (optional - can be customized per notification type)
      actions: [
        {
          action: 'open',
          title: 'Open',
          icon: '/icons/icon-96x96.png'
        },
        {
          action: 'close',
          title: 'Dismiss',
          icon: '/icons/icon-96x96.png'
        }
      ]
    }

    // Add image if available
    if (payload.notification?.image) {
      notificationOptions.image = payload.notification.image
    }

    // Show notification - browser/Android will automatically play default notification sound
    console.log('[SW] ðŸ”” Showing notification:', notificationTitle)
    return self.registration.showNotification(notificationTitle, notificationOptions)
  })
}

// Handle push events (alternative method for receiving notifications)
self.addEventListener('push', (event) => {
  console.log('[SW] ðŸ“¨ Push event received')

  if (event.data) {
    try {
      const data = event.data.json()
      console.log('[SW] Push data:', data)

      // This is handled by onBackgroundMessage above
      // But we keep this as a fallback
    } catch (error) {
      console.error('[SW] Error parsing push data:', error)
    }
  }
})

// Handle notification click (WhatsApp-like behavior)
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] ðŸ‘† Notification clicked:', event)

  // Close the notification
  event.notification.close()

  // Handle action buttons
  if (event.action === 'close') {
    console.log('[SW] User dismissed notification')
    return
  }

  // Get the URL from notification data
  const urlToOpen = new URL(
    event.notification.data?.url || '/dashboard',
    self.location.origin
  ).href

  console.log('[SW] Opening URL:', urlToOpen)

  // Open or focus the app window
  event.waitUntil(
    clients.matchAll({
      type: 'window',
      includeUncontrolled: true
    }).then((clientList) => {
      console.log('[SW] Found', clientList.length, 'open windows')

      // Try to find an existing window with the target URL
      for (const client of clientList) {
        const clientUrl = new URL(client.url)
        const targetUrl = new URL(urlToOpen)

        // Check if the path matches (ignore query params for matching)
        if (clientUrl.pathname === targetUrl.pathname && 'focus' in client) {
          console.log('[SW] Focusing existing window')
          return client.focus().then(() => {
            // Send message to client to update if needed
            return client.postMessage({
              type: 'NOTIFICATION_CLICKED',
              url: urlToOpen,
              data: event.notification.data
            })
          })
        }
      }

      // If there's any window open, focus it and navigate
      if (clientList.length > 0 && 'focus' in clientList[0]) {
        console.log('[SW] Focusing first window and navigating')
        return clientList[0].focus().then(() => {
          return clientList[0].postMessage({
            type: 'NOTIFICATION_CLICKED',
            url: urlToOpen,
            data: event.notification.data
          })
        })
      }

      // If no window is open, open a new one
      if (clients.openWindow) {
        console.log('[SW] Opening new window')
        return clients.openWindow(urlToOpen)
      }
    }).catch((error) => {
      console.error('[SW] Error handling notification click:', error)
    })
  )
})

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  console.log('[Firebase SW] Notification closed:', event)
})

// Service worker activation
self.addEventListener('activate', (event) => {
  console.log('[Firebase SW] Service worker activated')
  event.waitUntil(clients.claim())
})

// Service worker installation
self.addEventListener('install', () => {
  console.log('[SW] Service worker installed')
  self.skipWaiting()
})
